<!-- TOC -->

- [动态规划](#动态规划)
    - [1.三角形最小路径和](#1三角形最小路径和)
        - [方法1：动态规划](#方法1动态规划)
        - [方法2：动态规划+空间优化](#方法2动态规划空间优化)

<!-- /TOC -->

# 动态规划
方法总结：使用状态转移方程，描述中间状态之间的关系，即描述前一个小结果和后一个小结果之间的关系，依据这个关系链依次推导，可以得到最终结果。

适用情形：中间状态（结果）依赖于前一次的状态（结果）

## 1.三角形最小路径和
直通车：[https://leetcode-cn.com/problems/triangle/](https://leetcode-cn.com/problems/triangle/)


### 方法1：动态规划
> 思路分析：关键是获取中间状态之间的关系，根据题意我们可以知道，用f表示计算最短路径函数的话，位置为triangle[i][j]时，最短路径和为f(i,j)=min(f(i-1, j), f(i-1, j-1)) + triangle[i][j]，意思就是当前元素的最短路径和等于相邻上层元素的最短路和中的较小值加上当前位置元素的值（注意边界条件：元素为当前层第一个或者最后一个的时候，相邻的上层元素可以唯一确定）

```python3
from typing import List


class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)  # 数组的长度（三角形的高度）
        f = [[0] * n for _ in range(n)]  # 保存每一层的结果，到当前层当前元素的最小路径
        f[0][0] = triangle[0][0]  # 第一层，第一个元素的结果就是三角形顶的值

        # 遍历获取每一层的结果
        for i in range(1, n):
            # 当前是第i行，从第二行（i=1表示第二行）开始
            # 这是边界条件，每一行的第一个元素只能由上一行的第一个元素获得
            f[i][0] = f[i - 1][0] + triangle[i][0]
            for j in range(1, i):
                # 第(i,j)个元素的结果，等于(i-1,j-1)和(i-1, j)中的较小值 加上 (i,j)处原本的值
                f[i][j] = min(f[i - 1][j], f[i - 1][j - 1]) + triangle[i][j]
            # 这是边界条件，每一行的第最后一个元素只能由上一行的最后一个元素获得
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        return min(f[n - 1])


print(Solution().minimumTotal([
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3]
]))
```

### 方法2：动态规划+空间优化
> 思路分析：上例子中用n*n的二维数组保存了每一层每个元素的结果，但是实际上可以只用一个n维数组就可以做到。当前元素的结果都是由上一层的结果和当前元素的值得到的，我们可以考虑临界情况，因为每一层都比上一层多一个元素，所以如果每一层从最后一个元素遍历，得到最后一个元素的结果，此时并不会改变已经得到的上一层各个元素的结果，再依次往前将上一层的结果经过计算替换成当前层的结果就行了。

|下标（层）|当前状态（结果）|当前层的值|说明|
|---|---|---|---|
|0 |[2, 0, 0, 0] |[2]|第一层只占用了一个位置|
|1 |[5, 6, 0, 0] |[3, 4]||
|2 |[11, 10, 13, 0] |[6, 5, 7]|
|3 |[15, 11, 18, 16] |[4, 1, 8, 3]|

> 举例分析从下标1到2的情况：我们第2层（下标为1）的结果数组r=[5, 6, 0, 0]和第3层（下标为2）的数据源s=[6, 5, 7],想要得到第3层的结果，根据结果中的状态关系（注意临界情况）可得r[2]=r[1]+s[2]=6+7=13，此时r=[5,6,13,0]，可以看到新计算的第3层的最后一个位置的结果并未影响上一层的结果，继续计算r[1]=min(r[1], r[0]) + s[1]=5+5=10，此时r=[5,10,13,0]，
继续计算r[0]=r[0] + s[0]=11，此时r=[11,10,13,0]，与上表中第3层的记过一致。

```python3
from typing import List


class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)  # 数组的长度（三角形的高度）
        f = [0] * n  # 保存每一层的结果，到当前层当前元素的最小路径
        f[0] = triangle[0][0]  # 第一层，第一个元素的结果就是三角形顶的值

        # 遍历获取每一层的结果
        for i in range(1, n):
            f[i] = f[i-1] + triangle[i][i]  # 边界条件，f[i]是最后一个元素
            for j in range(i-1, 0, -1):
                # 第(i,j)个元素的结果，等于(i-1,j-1)和(i-1, j)中的较小值 加上 (i,j)处原本的值
                f[j] = min(f[j-1], f[j]) + triangle[i][j]
            # 这是边界条件，每一行的第最后一个元素只能由上一行的最后一个元素获得
            f[0] = f[0] + triangle[i][0]
        return min(f)


print(Solution().minimumTotal([
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3]
]))
```


